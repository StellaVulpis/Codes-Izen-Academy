-객체를 만드는 이유: 데이터를 압축하기 위해, 클래스 내부의 필드와 메서드를 사용하기 위해.
-오버라이딩: 재정의, 기능을 다시 부여함

만약 생성자가 다른 클래스에서 
변수, 메소드를 불러온다면

extends로 부모클래스를 상속받아서
super로 호출할 수 있다면 왜
생성자와 super, extends 상속이 동시에
존재하는가

>> 둘 다 비슷한 기능을 하지만 
new로 생성해서 호출자를 만드는 이유는
여러개의 클래스를 동시다발적으로 
호출해서 메서드와 변수를 사용하기 위함.

extends, super는 하나의 부모에서 상속받아서
사용하기 위함. 

결론: 용도가 서로 다른 것으로 추정.


// 진법 변환 (10진수 >> 이진수 변환도 시간나면 해보기)
    	// << >> 비트 이동
    	// a&b: 두 값의 비트가 전부 1이면 1(true), 서로 다르거나 하나 이상이 0일 때 0(false)으로 계산. (11 >> 1, 00 > 0, 01 >> 0, 10 >> 0)
    	/*
    	 * a: 	 	10001001
    	 * b:	 	11110111
    	 * result: 	 	10000001
    	 * */
    	// a|b: 두 값의 비트 중 하나 이상(01, 10, 11)이 1이면 1(true), 전부 0이면 0(false)으로 계산. (01 >> 1, 10 >> 1, 11 >> 1, 00 > 0)
    	/*
    	 * a: 	 	    10001001
    	 * b:	 	    11110111
    	 * result:	 	11111111
    	 * */
    	// a^b: 두 값의 비트가 서로 다르면 1(true), 같으면 0(true)으로 계산. (10 >> 1, 01 >> 1, 00 >> 0, 11 >> 0)
    	/*
    	 * a: 	 	    10001001
    	 * b:	 	    11110111
    	 * result:	 	01111110
    	 */
    	// ~: 비트 반전 연산자 (해당 비트를 반전) (11 >> 00, 00 >> 11, 10 >> 01, 01 >> 10)
    	/*
    	 * a: 		10010100
    	 * result: 		01101011
    	 * */
    	int a=30, b=60; /*
    					 * 011110 (30)
    					 * 111100 (60)
    					 * -----------
    					 * 111110 (62)
    	 				*/ 
    	int result= a | b;
    	System.out.println(result);
    	int num=37, shift=0; 		  // 37(000000100101) (왼쪽으로 3자리 이동)
    	shift=num<<3; 		// shift == 296(000100101000) <<
    	System.out.println(shift);
